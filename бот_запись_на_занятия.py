# -*- coding: utf-8 -*-
"""Бот запись на занятия.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U97u4Aogyd-egodtrd0AmSZYRJVdjvEP
"""

from __future__ import annotations
from __future__ import print_function
from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import CallbackQuery, ReplyKeyboardRemove, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import Command
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import LabeledPrice
from aiogram.contrib.middlewares.logging import LoggingMiddleware
import asyncio
import aioschedule
from aiogram.types import Message, ContentType
import logging
import pandas as pd
import gspread
from google.oauth2.service_account import Credentials
import nest_asyncio
import json
from typing import TYPE_CHECKING, Any, Optional

import datetime
from datetime import timedelta
import googleapiclient
from google.oauth2 import service_account
from googleapiclient.discovery import build
from dateutil import parser, tz

nest_asyncio.apply()
logging.basicConfig(format=u'%(filename)+13s [ LINE:%(lineno)-4s] %(levelname)-8s [%(asctime)s] %(message)s',
                    level=logging.INFO)

PROXY_URL = "http://proxy.server:3128"

bot = Bot(token = "6612561653:AAHVB_upR7NZInUUrx_KIbQTjWnDTiSMQxs", proxy = PROXY_URL)
dp = Dispatcher(bot, storage=MemoryStorage())

payment_token = '381764678:TEST:65509'

with open('data_bottg.json', 'r') as f:
      data_json = json.load(f)

def read_json():
    with open('data_bottg.json', 'r') as f:
      data_json = json.load(f)
    return data_json

def update_json(data):
    with open('data_bottg.json', 'w') as f:
      json.dump(data, f, ensure_ascii=False, indent=4)

scopes = [
'https://www.googleapis.com/auth/spreadsheets',
'https://www.googleapis.com/auth/drive'
]

credentials = Credentials.from_service_account_file('lessons-bot-28bd6cf813b5.json',scopes=scopes)
gc = gspread.authorize(credentials)

sh = gc.open("Копия DB students")


but = [types.KeyboardButton(text="Записаться", callback_data='Запись'), types.KeyboardButton(text="Отменить запись", callback_data='Отмена')]

markup = types.ReplyKeyboardMarkup()
markup.add(*but)

but_buy = [types.KeyboardButton(text="/buy", callback_data='Buy'), types.KeyboardButton(text="/back", callback_data='Back')]
markup_buy = types.ReplyKeyboardMarkup()
markup_buy.add(*but_buy)

# markup = types.InlineKeyboardMarkup(inline_keyboard=buttons, input_value={'row_width': 1})

user = {} # # id: fio (пользователи)
count = 0
records = {} # записанные даты и время
# price = types.LabeledPrice(label='Запись на занятия', amount=500 * 100)


class Auth(StatesGroup):
    fio = State()
    date = State()
    time = State()

class Commands(StatesGroup):
  back = State()

worksheet = sh.worksheet('Основа')
list_of_lists = worksheet.get_all_values() # Список таблицы
values_list_fio = worksheet.col_values(2) # ФИО
values_list_hours = worksheet.col_values(5)
values_list_done = worksheet.col_values(6)
last_elem = len(values_list_fio) # Последняя фамилия

Price = types.LabeledPrice(label='Запись на занятие', amount=500*100)

dates_week_label = []   # неделя, начиная с сегодняшнего дня
for i in range(1,8):
  date_next_week = (datetime.datetime.today() + timedelta(days=i)).strftime('%d.%m.%y')
  date_next_week = date_next_week[:date_next_week.rfind('.')]
  dates_week_label.append(date_next_week)
markup_dates = types.ReplyKeyboardMarkup()
for i in dates_week_label:
    markup_dates.add(i)

times_labels = ['7:30', '9:00', '10:30', '12:00', '13:30', '15:00', '16:30', '18:00', '19:30', '21:00']
markup_times = types.ReplyKeyboardMarkup()
for i in times_labels:
    markup_times.add(i)


SCOPES = ['https://www.googleapis.com/auth/calendar']

calendarId = 'zapisnazanatiabot@gmail.com'
SERVICE_ACCOUNT_FILE = 'steam-habitat-399123-ca85264a8056.json'

class GoogleCalendar(object):

    def __init__(self):
        credentials = service_account.Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)
        self.service = googleapiclient.discovery.build('calendar', 'v3', credentials=credentials)

    # создание словаря с информацией о событии
    def create_event_dict(self, fio, start_time, end_time):
        event = {
            'summary': fio,
            'description': 'Занятие',
            'start': {
                'dateTime': start_time,
            },
            'end': {
                'dateTime': end_time,
            }
        }
        return event

    # создание события в календаре
    def create_event(self, event):
        e = self.service.events().insert(calendarId=calendarId,
                                         body=event).execute()
        print('Event created: %s' % (e.get('id')))

# command /start
@dp.message_handler(commands=['start'])
async def start(message: types.Message, state: FSMContext):
  await message.answer(f"Доброго времени суток!\nДобро пожаловать в чат-бота записи на занятия.\nДля авторизации напишите свои *ФИО (полностью).*\nВнимательно проверьте, что Вы правильно ввели данные\n*Если Вы случайно опечатались, то нажмите ещё раз на /start.*", parse_mode = 'Markdown')
  await Auth.fio.set()

# command /back
@dp.message_handler(commands=['back'], state = '*')
async def back(message: types.Message, state: FSMContext):
  await message.answer("Выберите действие: Записаться на занятие или отменить запись.\nЧтобы возвращаться к данному меню вводите /back",  reply_markup = markup, parse_mode='Markdown')
  await state.finish()

# получение ФИО
@dp.message_handler(state = Auth.fio)
async def get_fio(message: types.Message, state: FSMContext):
    await state.update_data(fio=message.text)
    id = message.chat.id
    data_json = read_json()
    if str(id) not in data_json:
        data_json[str(id)] = {}
        update_json(data_json)
    fio_auth = message.text.title().split(' ')
    if len(fio_auth) == 3:
        # global fio
        # fio = message.text.title()
        if id not in user:
            user[id] = message.text.title()
        user[id] = message.text.title()
        data_json = read_json()
        if str(id) not in data_json or user[id] not in data_json[str(id)]:
            if str(id) not in data_json:
                data_json[str(id)] = {}
            data_json[str(id)][user[id]] = {}
            update_json(data_json)
        await message.answer("Выберите действие: Записаться на занятие или отменить запись.\nЧтобы возвращаться к данному меню вводите /back",  reply_markup = markup, parse_mode='Markdown')
        await state.finish()
    else:
        await message.answer("Пожалуйста, введите правильно своё ФИО для авторизации", parse_mode='Markdown')

# keyboard "Записаться"
@dp.message_handler(lambda message: message.text == "Записаться")
async def record(message: types.Message, state: FSMContext):
    id=message.chat.id
    list_of_lists = worksheet.get_all_values()
    values_list_hours = worksheet.col_values(5)
    values_list_done = worksheet.col_values(6)
    if user[id] not in values_list_fio:
 # считаем длину листа, чтобы под него вписать челибоксика
        worksheet.update_cell(last_elem + 1, 2, user[id]) # вписываем фио по указанным коордам
        worksheet.update_cell(last_elem + 1, 5, 0)
        worksheet.update_cell(last_elem + 1, 6, 0)
        list_of_lists = worksheet.get_all_values()
        await message.reply(f'Произведите оплату, для этого нажмите кнопку /buy', parse_mode='Markdown', reply_markup=markup_buy)
      # Записать в таблицу (оплаченные часы 0) --> Платежная система --> !Добавить оплаченный час в таблицу!
    else:
      for i in values_list_fio[1:]:
        if i == user[id]:
          cell = worksheet.find(i)
          if (int(values_list_hours[cell.row-1]) - int(values_list_done[cell.row-1])) > 0:
            for i in dates_week_label:
              markup_dates.add(i)
            await message.reply(f'Выберите удобную Вам дату занятия', parse_mode='Markdown', reply_markup = markup_dates)
            await state.set_state(Auth.date.state)
            # Выберите дату и время --> Записать в календарь --> Вы записаны {n} числа в {hh:mm}
          else:
            await message.reply(f'Произведите оплату, для этого нажмите кнопку /buy', parse_mode='Markdown',  reply_markup=markup_buy)
          # Платежная система -- > Выберите дату и время --> Запись в календарь --> Вы записаны {n} числа в {hh:mm}

    # await message.reply("Вы записаны!")

# keyboard "Отменить запись"
@dp.message_handler(lambda message: message.text == "Отменить запись")
async def cancel_recording(message: types.Message):
    await message.answer(f'Запись отменена', parse_mode='Markdown')
    # Удаление записи из календаря --> Кнопка отменить запись с перечислением всех занятий --> Вы отменили запись --> удаление из календаря

    # await message.reply("Ваша запись отменена!")

# command /buy
@dp.message_handler(commands=['buy'])
async def buy(message: types.Message):
    await bot.send_invoice(message.chat.id,
    title='Запись на занятия ',
    description='Запись на  следущее занятие',
    provider_token=payment_token,
    currency='rub',
    is_flexible=False,
    prices=[Price],
    start_parameter='one-month-subscription',
    payload='test-invoice-payload')
    await message.answer('', reply_markup=types.ReplyKeyboardRemove())

# пре-чекаут (ответ серверу должен быть отправлен в течение 10 секунд, иначе платеж не пройдет) / pre-checkout
@dp.pre_checkout_query_handler(lambda query: True)
async def pre_checkout_query(pre_checkout_q: types.PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_q.id, ok=True)

# успешная оплата / succesful payment
@dp.message_handler(content_types=ContentType.SUCCESSFUL_PAYMENT)
async def successful_payment(message: types.Message, state: FSMContext):
    print("SUCCESSFUL PAYMENT:")
    payment_info = message.successful_payment.to_python()
    for k, v in payment_info.items():
        print(f"{k} = {v}")
    # for i in dates_week_label:
    #     markup_dates.add(i)
    markup_dates = types.ReplyKeyboardMarkup()
    for i in dates_week_label:
        markup_dates.add(i)
    await bot.send_message(message.chat.id,
                           f"Платёж на сумму {message.successful_payment.total_amount // 100} {message.successful_payment.currency} прошёл успешно! Выбери удобную тебе дату для занятия.", reply_markup = markup_dates)
     # запись оплаченного занятия в гугл шитс
    list_of_lists = worksheet.get_all_values()
    values_list_hours = worksheet.col_values(5)
    values_list_fio = worksheet.col_values(2)
    id=message.chat.id
    for i in values_list_fio:
      if i == user[id]:
        cell = worksheet.find(i)
        # if (int(values_list_hours[cell.row-1]) - int(values_list_done[cell.row-1])) == 0:
        worksheet.update_cell(cell.row, 5, int(values_list_hours[cell.row-1]) + 1)
        list_of_lists = worksheet.get_all_values()
    await state.set_state(Auth.date.state)

# получение даты
@dp.message_handler(state = Auth.date)
async def get_date(message: types.Message, state: FSMContext):
    markup_times = ReplyKeyboardMarkup()
    for i in times_labels:
        markup_times.add(i)
    id = message.chat.id
    if message.text in dates_week_label:
        async with state.proxy() as data:
            data['date'] = message.text
            data['time'] = []
            # global date
            # date = message.text
            data_json = read_json()
            if str(id) in data_json and user[id] in data_json[str(id)]:
                if data['date'] not in data_json[str(id)][user[id]]:
                    data_json[str(id)][user[id]][data['date']] = []
                    update_json(data_json)
            await message.answer('Выберите время', reply_markup = markup_times)
            await state.set_state(Auth.time.state)
    else:
        await message.answer("Выбери дату записи с клавиатуры", parse_mode = 'Markdown', reply_markup = markup_dates)
    # if date not in records.keys():
    #     records[date] = ''

# получение времени
@dp.message_handler(state = Auth.time)
async def get_time(message: types.Message, state: FSMContext):
    id = message.chat.id
    if message.text in times_labels:
      async with state.proxy() as data:
        data['time'].append(message.text)
        date = data['date']
        times = data['time']
        # data['time'] = message.text
        # global time
        # time = message.text
        # записываем время в json
        data_json = read_json()
        if str(id) in data_json and user[id] in data_json[str(id)] and date in data_json[str(id)][user[id]]:
            for time in times:
                if time not in data_json[str(id)][user[id]][date]:
                    data_json[str(id)][user[id]][date].append(time)
            update_json(data_json)

            # if time not in data_json[str(id)][user[id]][date]:
            #     data_json[str(id)][user[id]][date].append(time)
            #     update_json(data_json)
        # удаляем из файла выбранное время
        for id_ in data_json:
            for fio_ in data_json[id_]:
                for dates in data_json[id_][fio_]:
                    if date == dates:
                      for times in data_json[id_][fio_][date]:
                        if time == times:
                            times_labels.remove(time)
        # обновляем клавиатуру
        markup_times = ReplyKeyboardMarkup()
        for i in times_labels:
            markup_times.add(i)
        await message.answer(f'Вы записаны на {date} в  {time}.', reply_markup = markup)
        await state.finish()
        # добавляем + 1 откатанное занятие
        list_of_lists = worksheet.get_all_values()
        values_list_hours = worksheet.col_values(5)
        values_list_done = worksheet.col_values(6)
        values_list_fio = worksheet.col_values(2)
        id = message.chat.id
        for i in values_list_fio:
          if i == user[id]:
            cell = worksheet.find(i)
            worksheet.update_cell(cell.row, 6, int(values_list_done[cell.row-1])+1)
            list_of_lists = worksheet.get_all_values()
        # приведение подученной даты к формату, необходиимому в гугл-календаре
        time_format = '%H:%M'
        delta = timedelta(hours=1.5)
        start_time = datetime.datetime.strptime(time, time_format)
        new_time = start_time + delta
        new_time_str = new_time.strftime(time_format)
        # Преобразование переменных date и time в объект datetime
        datetime_obj_start = datetime.datetime.strptime(f"2023-{date} {time}", "%Y-%d.%m %H:%M")
        datetime_obj_end = datetime.datetime.strptime(f"2023-{date} {new_time_str}", "%Y-%d.%m %H:%M")
        # Преобразование объекта datetime в требуемый формат
        datetime_start = datetime_obj_start.strftime("%Y-%m-%dT%H:%M:%S%z")
        datetime_end = datetime_obj_end.strftime("%Y-%m-%dT%H:%M:%S%z")
        # Преобразуем строку в объект datetime с указанным часовым поясом
        dt_start = parser.parse(datetime_start)
        dt_end = parser.parse(datetime_end)
        dt_start_timezone = dt_start.replace(tzinfo=tz.gettz('Europe/Moscow'))
        dt_end_timezone = dt_end.replace(tzinfo=tz.gettz('Europe/Moscow'))
        # Преобразуем объект datetime в строку с указанием часового пояса
        date_start_timezone = dt_start_timezone.isoformat()
        date_end_timezone = dt_end_timezone.isoformat()
        # Запись в календарь
        calendar = GoogleCalendar()
        event = calendar.create_event_dict(user[id], date_start_timezone, date_end_timezone)
        calendar.create_event(event)
        # else:
        #     await message.answer('Данное время уже занято. Пожалуйста, выберите другое. Для этого нажмите /back', reply_markup=types.ReplyKeyboardRemove())
    else:
      await message.answer('Выберите время с клавиатуры', reply_markup = markup_times)
        # records[date] = time

# async def send_message_to_users():
# #   while True:
#     now = datetime.datetime.now() + timedelta(hours=3)
#     if now.weekday() == 6 and now.hour == 3 and now.minute == 41:
#       for user in user:
#         await bot.send_message(user, "Привет! Открылась запись на следующую неделю.")
#     await asyncio.sleep(60)  # проверяем текущее время каждую минуту

# @dp.message_handler()
# async def send_message():
#     for us in user:
#         await bot.send_message(us, "Привет! Открылась запись на следующую неделю.")

# async def scheduler():
#     aioschedule.every().monday.at("00:10").do(send_message())
#     while True:
#         await aioschedule.run_pending()
#         await asyncio.sleep(1)

# async def on_startup(dp):
#     asyncio.create_task(scheduler())

# async def scheduled(wait_for):
#     while True:
#         # Получаем текущую дату и время
#         now = datetime.datetime.now() + timedelta(hours = 3)
#         # Если сейчас четверг и время 12:00, отправляем сообщение
#         if now.weekday() == 0 and now.hour == 21 and now.minute == 49:
#             # Получаем список всех пользователей бота
#             users = await dp.bot.get_chat_members(chat_id=dp.bot.get_me().id)
#             # Отправляем сообщение каждому пользователю
#             for user in users:
#                 # Проверяем, что пользователь - не бот
#                 if not user.is_bot:
#                     await bot.send_message(chat_id=user.user.id, text="Привет! Это сообщение отправлено каждый четверг в 12:00.")
#         # Ожидаем до следующего четверга 12:00
#         await asyncio.sleep(wait_for)



# async def on_startup(dp):
#     await bot.send_message(chat_id='YOUR_CHAT_ID', text="Бот запущен")

# Запускаем бота и планируем задачу отправки сообщения каждый четверг в 12:00
# if __name__ == '__main__':
    # loop = asyncio.get_event_loop()
    # loop.create_task(scheduled(60))
    # executor.start_polling(dp, skip_updates=False)

# print(user)

if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=False)